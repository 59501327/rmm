@Library('gpuci_shared_lib') _

pipeline {
  agent any
  options {
    buildDiscarder(logRotator(numToKeepStr: '1')) 
    ansiColor('xterm')
  }
  stages {
    stage("Build Stage") { 
      steps {
        sh "env"
        echo "${currentBuild.buildCauses}"
      }

      // parallel {
      //   stage('Check Size') {
      //     agent { label "runner" }
      //     environment {
      //       GHTK = credentials('GHTK')
      //       BUILD_TYPE = 'size'
      //       BUILD_MODE = 'pull-request'
      //       COMMIT_HASH = "${env.GIT_COMMIT}"
      //       TARGET_BRANCH = "${env.CHANGE_TARGET}"
      //       REPORT_HASH = "${env.GIT_COMMIT}" // TODO: figure out
      //     }
      //     withRemoteDocker( //TODO: replace
      //       debug: false, 
      //       main: <object of type com.gpuopenanalytics.jenkins.remotedocker.job.DockerImageConfiguration>, 
      //       sideContainers: [], 
      //       workspaceOverride: '/workspace') {
      //         // some block
      //     }

      //     steps {
      //       cleanWs (
      //         cleanWhenAborted: false, 
      //         cleanWhenFailure: false, 
      //         cleanWhenSuccess: false, 
      //         cleanWhenUnstable: false, 
      //         deleteDirs: true, 
      //         externalDelete: 'sudo rm -rf %s'
      //       )

      //       sh """#!/bin/bash
      //         set -e
      //         set +x
      //         curl -s -XPOST -H "Authorization: token \$GHTK" "https://api.github.com/repos/rapidsai/rmm/statuses/${REPORT_HASH}" -d "{
      //           \\"state\\": \\"pending\\",
      //           \\"context\\": \\"gpuci/rmm/check/style\\",
      //           \\"target_url\\": \\"\${BUILD_URL}console\\",
      //           \\"description\\": \\"Running\\"
      //         }" 2>&1 > /dev/null
      //         unset GHTK
      //       """

      //       sh '''#!/bin/bash
      //         set -e

      //         DIFF_FILES=$(mktemp)
      //         LARGE_FILES=$(mktemp)
      //         FILESIZE_LIMIT=5242880
      //         RETVAL=0

      //         # Activate rapids environment for Git LFS access
      //         . /opt/conda/etc/profile.d/conda.sh
      //         conda activate rapids

      //         # Checkout target branch
      //         git checkout --force $TARGET_BRANCH
      //         # Switch back to PR branch
      //         git checkout --force current-pr-branch
      //         # Checkout newest commit of PR branch
      //         git checkout -fq $COMMIT_HASH;

      //         # Get list of files changed in current PR
      //         git diff --name-only $TARGET_BRANCH..current-pr-branch > ${DIFF_FILES}

      //         echo '### Files modified in current PR'
      //         while read FILE; do 
      //             echo 'Size check ' $FILE
      //             if [ -f "$WORKSPACE/$FILE" ]; then
      //                 if [ `du -b "$WORKSPACE/$FILE" | awk '{print $1}'` -gt $FILESIZE_LIMIT ]; then 
      //                     RETVAL=1
      //                     echo $FILE >> ${LARGE_FILES}
      //                 fi
      //             fi
      //         done < ${DIFF_FILES}

      //         if [ $RETVAL == 1 ]; then
      //             echo "### Files exceeding the $FILESIZE_LIMIT size limit.  Please see documentation for" 
      //             echo "### large file handling:  https://docs.rapids.ai/resources/git/#large-files-and-git"
      //             cat  ${LARGE_FILES}  
      //             echo "###"
      //             else
      //             echo "### All files under the $FILESIZE_LIMIT size limit"
      //         fi

      //         rm -f ${DIFF_FILES} ${LARGE_FILES}
      //         exit $RETVAL           
      //       '''
      //     }


      //     post {
      //       always {
      //         step([
      //             $class: "GitHubCommitStatusSetter",
      //             reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/rapids-ai/rmm"],
      //             contextSource: [$class: "ManuallyEnteredCommitContextSource", context: "gpuci/rmm/check/size"],
      //             errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      //             statusResultSource: [ 
      //               $class: "ConditionalStatusResultSource", 
      //               results: [
      //                 [$class: 'BetterThanOrEqualBuildResult', result: 'SUCCESS', state: 'SUCCESS', message: build.description],
      //                 [$class: 'BetterThanOrEqualBuildResult', result: 'FAILURE', state: 'FAILURE', message: build.description],
      //                 [$class: 'AnyBuildResult', state: 'FAILURE', message: 'Loophole']
      //               ]
      //             ]
      //         ]);

      //         cleanWs (
      //           cleanWhenAborted: true, 
      //           cleanWhenFailure: true, 
      //           cleanWhenNotBuilt: true,
      //           cleanWhenSuccess: true, 
      //           cleanWhenUnstable: true, 
      //           deleteDirs: true,
      //           disableDeferredWipeout: true,
      //         )
      //       }
      //     }
      //   }

      //   stage('Check Style') {
      //     agent { label "runner" }
      //     environment {
      //       GHTK = credentials('GHTK')
      //       BUILD_TYPE = 'style'
      //       BUILD_MODE = 'pull-request'
      //     }
      //     withRemoteDocker( // TODO: update
      //       debug: false, 
      //       main: <object of type com.gpuopenanalytics.jenkins.remotedocker.job.DockerImageConfiguration>, 
      //       sideContainers: [], 
      //       workspaceOverride: '/workspace') {
      //         // some block
      //     }

      //     steps {
      //       cleanWs (
      //         cleanWhenAborted: false, 
      //         cleanWhenFailure: false, 
      //         cleanWhenSuccess: false, 
      //         cleanWhenUnstable: false, 
      //         deleteDirs: true, 
      //         externalDelete: 'sudo rm -rf %s'
      //       )

      //       sh '''#!/bin/bash
      //         set -e
      //         TMPDIR="\${WORKSPACE}/tmp"

      //         BUILD_SCRIPT="ci/checks/style.sh"
      //         cd "$WORKSPACE"

      //         hostname
      //         env > env.list
      //         if [ -f $BUILD_SCRIPT ]; then
      //             echo ">>>> Detected in repo script, using '${BUILD_SCRIPT}' for build..."
      //             source ${BUILD_SCRIPT}
      //             exit $?
      //         else
      //         echo ">>>> ERROR: No script '${BUILD_SCRIPT}' detected..."
      //             exit 1
      //         fi
      //       '''
      //     }


      //     post {
      //       always {
      //         step([
      //             $class: "GitHubCommitStatusSetter",
      //             reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/rapids-ai/rmm"],
      //             contextSource: [$class: "ManuallyEnteredCommitContextSource", context: "gpuci/rmm/check/style"],
      //             errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      //             statusResultSource: [ 
      //               $class: "ConditionalStatusResultSource", 
      //               results: [
      //                 [$class: 'BetterThanOrEqualBuildResult', result: 'SUCCESS', state: 'SUCCESS', message: build.description],
      //                 [$class: 'BetterThanOrEqualBuildResult', result: 'FAILURE', state: 'FAILURE', message: build.description],
      //                 [$class: 'AnyBuildResult', state: 'FAILURE', message: 'Loophole']
      //               ]
      //             ]
      //         ]);

      //         cleanWs (
      //           cleanWhenAborted: true, 
      //           cleanWhenFailure: true, 
      //           cleanWhenNotBuilt: true,
      //           cleanWhenSuccess: true, 
      //           cleanWhenUnstable: true, 
      //           deleteDirs: true,
      //           disableDeferredWipeout: true,
      //         )
      //       }
      //     }
      //   }
      // }
    }
    stage("C++ Matrix Build") {
      environment {
        buildCudaVarName = '1'
        BUILD_TYPE = 'cpu'
        BUILD_MODE = 'pull-request'
        REPO = "rmm"
        PARALLEL_LEVEL = '4'
        CUDA="11.5"
        // GHTK = credentials('GHTK')
      }
      steps {
        sh "echo starting C++ matrix builds"
        sh 'printenv'
        // cleanWs (
        //   deleteDirs: true, 
        //   externalDelete: 'sudo rm -rf %s'
        // )

        // timeout(time: 2400, unit: 'SECONDS') {
        //   catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
        //     sh "exit 1"
        //   }           
        // }

        script {
          parallel generateStage("cuda_build", {
            checkout scm

            withCredentials([[
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: "aws-s3-gpuci",
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]) {
              sh '''#!/bin/bash
                set -e
                TMPDIR=${WORKSPACE}/tmp

                unset SUDO_UID SUDO_GID SUDO_USER
                BUILD_SCRIPT="ci/build_cpp.sh"

                export NVCC="/usr/local/cuda/bin/nvcc"
                export CUDAToolkit_ROOT="/usr/local/cuda"
                export CUDACXX="/usr/local/cuda/bin/nvcc"

                cd "$WORKSPACE"

                #Override nvidia-smi to exit on 0 and 14 as succesful
                #14 is infoROM corrupted
                function nvidia-smi() {
                    /usr/bin/nvidia-smi $@
                    EXIT_VAL=$?
                    if [[ $EXIT_VAL == 0 || $EXIT_VAL == 14 ]]; then
                        return 0
                    fi
                    exit $EXIT_VAL
                }

                cd "$WORKSPACE"
                if [ -f $BUILD_SCRIPT ]; then
                    echo ">>>> Detected in repo script, using '${BUILD_SCRIPT}' for build..."
                    source ${BUILD_SCRIPT}
                else
                    echo ">>>> ERROR: No script '${BUILD_SCRIPT}' detected..."
                    exit 1
                fi
              '''                
            }

            echo "Hello CUDA!"
          })
        }
      }

      // post {
      //   always {
      //     publishHTML (target : [allowMissing: true,
      //       alwaysLinkToLastBuild: false,
      //       keepAll: true,
      //       reportFiles: 'BuildMetrics.html, ninja.log',
      //       reportName: 'Build Metrics Report',
      //       reportTitles: 'Build Metrics Details, Ninja Log'])
      //   }
      // }
    }

    stage("Python Matrix Build") {
      environment {
        CUDA="11.5"
      }
      steps {
        script {
          parallel generateStage("python_build", {
            checkout scm

            withCredentials([[
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: "aws-s3-gpuci",
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]) {
              sh '''#!/bin/bash
                set -e
                TMPDIR=${WORKSPACE}/tmp

                unset SUDO_UID SUDO_GID SUDO_USER
                BUILD_SCRIPT="ci/build_py.sh"

                export NVCC="/usr/local/cuda/bin/nvcc"
                export CUDAToolkit_ROOT="/usr/local/cuda"
                export CUDACXX="/usr/local/cuda/bin/nvcc"

                cd "$WORKSPACE"
                if [ -f $BUILD_SCRIPT ]; then
                    echo ">>>> Detected in repo script, using '${BUILD_SCRIPT}' for build..."
                    source ${BUILD_SCRIPT}
                else
                    echo ">>>> ERROR: No script '${BUILD_SCRIPT}' detected..."
                    exit 1
                fi
              '''                
            }
            echo "Hello Python!"
          })
        }
      }
    }

    stage("PR/Branch Test Stage") {
      when { not { triggeredBy 'TimerTrigger' } }
      environment {
        CUDA="11.5"
        UPLOAD_PKGS = """${sh(
              returnStdout: true,
              script: 'echo "$GIT_BRANCH" | grep -iq "pr" && echo "false" || echo "true"'
          )}"""
      }
      steps {
        sh "env"
        echo "${currentBuild.buildCauses}"
        script {
          parallel generateStage("branch_pr_test",{
            checkout scm
            withCredentials([[
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: "aws-s3-gpuci",
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
            ]]) {    
              echo "hello from rmm repo"
              echo "Upload packages: \${UPLOAD_PKGS}"
              sh '''#!/bin/bash
                source ci/gpu_test.sh
              '''         
            }
          })
        }
      }
    }

    stage("Nightly Test Stage") {
      when { triggeredBy 'TimerTrigger' }
      environment { UPLOAD_PKGS = "true" }
      steps {
        sh "env"
        echo "${currentBuild.buildCauses}"
        script {
          parallel generateStage("nightly_test", {
            checkout scm
            echo "Upload packages: \${UPLOAD_PKGS}"
            echo "Uploading packages..."
          })
        }
      }
    }
  }
}